# -*- coding: utf-8 -*-
"""AI Bot To Read My Unstructured financial data sheet, Provide Answers Based On My Data, And Generate AI Insights 2.O .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-OHVNU2fKyKo8tVVvgAM0bH5xir2QVAg
"""

# Install dependencies
!pip install streamlit-tags pyngrok openai python-dotenv pandas pydantic requests beautifulsoup4 html2text tiktoken selenium readability-lxml streamlit openpyxl

# Install Chrome and ChromeDriver
!apt-get update
!apt install chromium-chromedriver
!cp /usr/lib/chromium-browser/chromedriver /usr/bin
# Install all dependencies
!pip install -q langchain-community langchain chromadb PyPDF2 pandas tiktoken sentence-transformers huggingface_hub python-dotenv matplotlib seaborn streamlit-tags pyngrok openai openpyxl transformers
!apt-get update
!apt install chromium-chromedriver
!cp /usr/lib/chromium-browser/chromedriver /usr/bin

!pip install PyPDF2 pandas matplotlib seaborn langchain huggingface-hub transformers streamlit pyngrok

!pip install streamlit pandas numpy plotly transformers PyPDF2 huggingface_hub requests

!pip install streamlit-extras streamlit-chat

!pip install PyPDF2

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import PyPDF2
# import os
# import re
# import json
# import base64
# import requests
# import pandas as pd
# import streamlit as st
# import plotly.express as px
# from PIL import Image
# import plotly.graph_objects as go
# from transformers import pipeline
# from annotated_text import annotated_text
# from streamlit_chat import message as chat_message
# from google.generativeai import configure, GenerativeModel
# 
# # Configuration
# st.set_page_config(layout="wide", page_title="FinAI Analyst Pro", page_icon="üìà")
# API_KEYS = {
#     "google_ai": "AIzaSyB7csovAYb5IkG4s_vUTXc3XNfyvrfPEyU",
#     "huggingface": "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"
# }
# 
# # Style Enhancements
# def local_css(file_name):
#     if os.path.exists(file_name):
#         with open(file_name) as f:
#             st.markdown(f'<style>{f.read()}</style>', unsafe_allow_html=True)
#     else:
#         st.warning(f"‚ö†Ô∏è Warning: {file_name} not found. Skipping custom styles.")
# 
# class FinancialAI:
#     def __init__(self):
#         self.pdf_text = None
#         self.df = pd.DataFrame()  # Initialize as an empty DataFrame
#         self.qa_history = []
#         configure(api_key=API_KEYS["google_ai"])
#         self.gemini = GenerativeModel('gemini-pro')
#         self.finbert = pipeline("sentiment-analysis",
#                              model="ProsusAI/finbert",
#                              token=API_KEYS["huggingface"])
# 
#     def process_pdf(self, file_path):
#         """Advanced PDF processing with metadata extraction"""
#         text = self._extract_pdf_text(file_path)
#         self.pdf_text = text
#         self.df = self._create_structured_data(text)
#         return text
# 
#     def _extract_pdf_text(self, file_path):
#         """Extract text with layout preservation"""
#         text = ""
#         with open(file_path, 'rb') as f:
#             reader = PyPDF2.PdfReader(f)
#             for page in reader.pages:
#                 text += page.extract_text() + "\n\n"
#         return text
# 
#     def _create_structured_data(self, text):
#         """Create structured financial dataframe"""
#         metrics = self._extract_metrics(text)
#         ratios = self._calculate_ratios(metrics)
#         trends = self._analyze_trends(text)
# 
#         # Create a DataFrame with metrics, ratios, and trends
#         financial_data = {
#             **metrics,
#             **ratios,
#             'trends': trends
#         }
#         return pd.DataFrame([financial_data])
# 
#     def _extract_metrics(self, text):
#         """Ensure metrics extraction always returns valid values"""
#         metrics = {
#             'revenue': self._find_metric(r'Revenue.*?([\d,.]+)', text) or 0,
#             'net_profit': self._find_metric(r'Net Profit.*?([\d,.]+)', text) or 0,
#             'total_assets': self._find_metric(r'Total Assets.*?([\d,.]+)', text) or 0,
#             'total_liabilities': self._find_metric(r'Total Liabilities.*?([\d,.]+)', text) or 0,
#             'equity': self._find_metric(r'Total Equity.*?([\d,.]+)', text) or 1,
#             'operating_cash_flow': self._find_metric(r'Operating Cash Flow.*?([\d,.]+)', text) or 0
#         }
#         return metrics
# 
#     def _find_metric(self, pattern, text):
#         """Helper function for metric extraction"""
#         match = re.search(pattern, text, re.IGNORECASE)
#         if match:
#             try:
#                 return float(match.group(1).replace(',', ''))
#             except ValueError:
#                 return 0
#         return 0
# 
#     def _calculate_ratios(self, metrics):
#         """Prevent division by zero errors with fallback values"""
#         ratios = {
#             'debt_to_equity': metrics['total_liabilities'] / metrics['equity'] if metrics['equity'] != 0 else 0,
#             'current_ratio': metrics['total_assets'] / metrics['total_liabilities'] if metrics['total_liabilities'] != 0 else 0,
#             'profit_margin': metrics['net_profit'] / metrics['revenue'] if metrics['revenue'] != 0 else 0
#         }
#         return ratios
# 
#     def _analyze_trends(self, text):
#         """AI-powered trend analysis with error handling"""
#         try:
#             prompt = f"Analyze this financial report and identify key trends:\n{text[:3000]}"
#             response = self.gemini.generate_content(prompt)
#             return response.text
#         except Exception as e:
#             return f"Trend analysis unavailable: {str(e)}"
# 
#     def generate_visualizations(self):
#         """Create interactive financial dashboards"""
#         figs = {}
# 
#         # Main Metrics Gauge
#         figs['gauge'] = go.Figure(go.Indicator(
#             mode="gauge+number",
#             value=self.df['net_profit'].iloc[0],
#             title={'text': "Net Profit"},
#             domain={'x': [0, 1], 'y': [0, 1]}
#         ))
# 
#         # Financial Health Radar
#         figs['radar'] = go.Figure()
#         figs['radar'].add_trace(go.Scatterpolar(
#             r=[self.df['revenue'].iloc[0], self.df['net_profit'].iloc[0],
#               self.df['total_assets'].iloc[0], self.df['equity'].iloc[0]],
#             theta=['Revenue','Net Profit','Assets','Equity'],
#             fill='toself'
#         ))
# 
#         # Time Series Analysis
#         if 'trends' in self.df.columns:
#             # Create a DataFrame without the 'trends' column for visualization
#             viz_df = self.df.drop(columns=['trends'])
#             figs['trends'] = px.line(
#                 viz_df,
#                 title="Financial Trends Analysis",
#                 markers=True
#             )
# 
#         return figs
# 
#     def ask_question(self, question):
#         """AI-powered financial Q&A"""
#         context = f"Financial Report Context:\n{self.pdf_text[:5000]}\n\nQuestion: {question}"
#         response = self.gemini.generate_content(context)
#         self.qa_history.append((question, response.text))
#         return response.text
# 
# # Streamlit UI
# def main():
#     st.title("üíπ FinAI Analyst Pro")
#     st.markdown("### AI-Powered Financial Document Analysis Suite")
# 
#     ai = FinancialAI()
# 
#     # File Upload Section
#     with st.sidebar:
#         st.header("Document Input")
#         uploaded_file = st.file_uploader("Upload Financial PDF", type="pdf")
# 
#         if uploaded_file:
#             with st.spinner("üß† Analyzing Document..."):
#                 with open("temp.pdf", "wb") as f:
#                     f.write(uploaded_file.getvalue())
#                 ai.process_pdf("temp.pdf")
#                 os.remove("temp.pdf")
#             st.success("Document processed successfully!")
# 
#     # Main Dashboard
#     if uploaded_file:
#         col1, col2 = st.columns([1, 2])
# 
#         with col1:
#             st.subheader("üìä Financial Metrics")
#             annotated_text(
#                 ("Revenue", f"${ai.df['revenue'].iloc[0]:,.2f}", "#afa"),
#                 ("Net Profit", f"${ai.df['net_profit'].iloc[0]:,.2f}", "#8ef"),
#                 ("Assets", f"${ai.df['total_assets'].iloc[0]:,.2f}", "#faa"),
#                 ("Debt/Equity", f"{ai.df['debt_to_equity'].iloc[0]:.2f}", "#ff6")
#             )
# 
#             st.subheader("üîç AI Insights")
#             with st.expander("Trend Analysis"):
#                 st.write(ai.df['trends'].iloc[0])
# 
#             with st.expander("Sentiment Analysis"):
#                 sentiment = ai.finbert(ai.pdf_text[:512])[0]
#                 st.metric(label="Financial Sentiment",
#                         value=sentiment['label'],
#                         delta=f"{sentiment['score']:.2f} confidence")
# 
#         with col2:
#             st.subheader("üìà Interactive Analytics")
#             viz = ai.generate_visualizations()
# 
#             tab1, tab2, tab3 = st.tabs(["Gauge", "Radar", "Trends"])
#             with tab1:
#                 st.plotly_chart(viz['gauge'], use_container_width=True)
#             with tab2:
#                 st.plotly_chart(viz['radar'], use_container_width=True)
#             with tab3:
#                 st.plotly_chart(viz['trends'], use_container_width=True)
# 
#         # Chat Interface
#         st.subheader("üí¨ Financial Q&A Assistant")
#         user_input = st.text_input("Ask any question about the financial report:")
# 
#         if user_input:
#             answer = ai.ask_question(user_input)
#             chat_message(user_input, is_user=True)
#             chat_message(answer, avatar_style="bottts")
# 
#         st.download_button(
#             label="üì• Download Full Analysis",
#             data=json.dumps(ai.df.to_dict()),
#             file_name="financial_analysis.json",
#             mime="application/json"
#         )
# 
# if __name__ == "__main__":
#     main()

def launch_financial_app():
    import os
    import streamlit as st
    from pyngrok import ngrok
    import subprocess
    import time

    # Environment setup
    os.environ["HUGGINGFACEHUB_API_TOKEN"] = "your_huggingface_token_here"

    def cleanup():
        """Clean up existing processes and tunnels"""
        try:
            subprocess.run(['killall', 'streamlit'], check=False)
            subprocess.run(['killall', 'ngrok'], check=False)
            ngrok.kill()
        except Exception as e:
            print(f"Cleanup error: {e}")

    def verify_streamlit():
        """Verify Streamlit is running"""
        import requests
        try:
            response = requests.get("http://localhost:8501")
            return response.status_code == 200
        except:
            return False

    try:
        # Initial cleanup
        cleanup()

        # Start Streamlit
        process = subprocess.Popen(
            ['streamlit', 'run', 'app.py', '--server.port', '8501'],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )

        # Wait for Streamlit to start
        attempts = 0
        while not verify_streamlit() and attempts < 5:
            time.sleep(2)
            attempts += 1

        if not verify_streamlit():
            raise Exception("Streamlit failed to start")

        # Configure and start ngrok
        ngrok.set_auth_token("2svGpIgl7dU65m2cWjFOtMvsIGu_2A221d9EYjrDP2TyDprFU")
        tunnel = ngrok.connect(8501, "http", bind_tls=True)

        print(f"App available at: {tunnel.public_url}")

        # Keep the script running
        try:
            while True:
                time.sleep(1)
        except KeyboardInterrupt:
            cleanup()

    except Exception as e:
        print(f"Error: {str(e)}")
        cleanup()

if __name__ == "__main__":
    launch_financial_app()

import google.generativeai as genai

genai.configure(api_key="AIzaSyB7csovAYb5IkG4s_vUTXc3XNfyvrfPEyU")

model = genai.GenerativeModel("gemini-pro")
response = model.generate_content("Hello, how are you?")
print(response.text)